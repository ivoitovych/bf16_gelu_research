// ============================================================================
// DOPRI-INSPIRED ADAPTIVE PIECEWISE POLYNOMIAL APPROXIMATIONS
// ============================================================================
//
// These methods use DOPRI-inspired adaptive step control to equalize errors
// across segments. Breakpoints are placed based on curvature and iteratively
// refined to minimize max error.
//
// Core approximation: [-3.5, 3.0]
// Negative tail: Uses gelu_negative_tail() for x < -3.5
// Positive tail: GELU(x) = x for x >= 3.0
//
// Generated by generate_dopri_coeffs.py
// ============================================================================

/**
 * @brief DOPRI Deg4 Seg8
 *
 * DOPRI-inspired adaptive piecewise polynomial approximation
 * Degree: 4, Segments: 8
 * Core region: [-3.5, 3.0]
 * Negative tail (x < -3.5): Uses gelu_negative_tail()
 * Positive tail (x >= 3.0): GELU(x) = x
 *
 * Operations: 4 MUL + 4 ADD + log2(8) CMP
 */
std::bfloat16_t gelu_dopri_deg4_seg8(std::bfloat16_t x_bf16) {
    float x = static_cast<float>(x_bf16);

    // Positive saturation
    if (x >= thresholds::POS) {
        return static_cast<std::bfloat16_t>(x);
    }

    // Negative tail: use specialized handler
    if (x < thresholds::TAIL_START) {
        return static_cast<std::bfloat16_t>(gelu_negative_tail(x));
    }

    // Breakpoints for segment lookup
    constexpr float breakpoints[] = {
        -3.50000000f, -2.10609838f, -0.76481332f, -0.11500455f, 0.10507331f,
        0.40932762f, 0.78517548f, 1.59224604f, 3.00000000f
    };

    // Coefficients [segment][coefficient]
    constexpr float coeffs[8][5] = {
        { -6.863992167890e-01f, -6.760132023283e-01f, -2.489351422629e-01f, -4.038834557305e-02f, -2.416586294522e-03f },
        { 3.473675276848e-02f, 6.597934889516e-01f, 6.889202367967e-01f, 2.554786083176e-01f, 3.296775009285e-02f },
        { 1.280418232010e-04f, 5.020959631315e-01f, 4.107638384299e-01f, 2.850594793063e-02f, -3.968152226177e-02f },
        { 7.188254725739e-10f, 5.000000000000e-01f, 3.989413016022e-01f, -1.134119482820e-12f, -6.629288984213e-02f },
        { 8.436754964740e-06f, 4.998038615451e-01f, 4.006172375678e-01f, -6.409830815964e-03f, -5.663273636711e-02f },
        { 1.459539611031e-03f, 4.874349464913e-01f, 4.408572346004e-01f, -6.596928683530e-02f, -2.262067447148e-02f },
        { 3.027021901846e-02f, 3.568959977849e-01f, 6.661305035446e-01f, -2.419967968477e-01f, 3.004967074569e-02f },
        { -3.101761019490e-01f, 1.062823522641e+00f, 1.233056319560e-01f, -5.936271168726e-02f, 7.540346029041e-03f },
    };

    // Binary search for segment (log2(8) comparisons)
    int seg = 0;
    int low = 0, high = 7;
    while (low < high) {
        int mid = (low + high + 1) / 2;
        if (x >= breakpoints[mid]) {
            low = mid;
        } else {
            high = mid - 1;
        }
    }
    seg = low;

    // Horner's method evaluation
    float result = coeffs[seg][4];
    result = result * x + coeffs[seg][3];
    result = result * x + coeffs[seg][2];
    result = result * x + coeffs[seg][1];
    result = result * x + coeffs[seg][0];

    return static_cast<std::bfloat16_t>(result);
}

/**
 * @brief DOPRI Deg4 Seg16
 *
 * DOPRI-inspired adaptive piecewise polynomial approximation
 * Degree: 4, Segments: 16
 * Core region: [-3.5, 3.0]
 * Negative tail (x < -3.5): Uses gelu_negative_tail()
 * Positive tail (x >= 3.0): GELU(x) = x
 *
 * Operations: 4 MUL + 4 ADD + log2(16) CMP
 */
std::bfloat16_t gelu_dopri_deg4_seg16(std::bfloat16_t x_bf16) {
    float x = static_cast<float>(x_bf16);

    // Positive saturation
    if (x >= thresholds::POS) {
        return static_cast<std::bfloat16_t>(x);
    }

    // Negative tail: use specialized handler
    if (x < thresholds::TAIL_START) {
        return static_cast<std::bfloat16_t>(gelu_negative_tail(x));
    }

    // Breakpoints for segment lookup
    constexpr float breakpoints[] = {
        -3.50000000f, -2.46024569f, -1.87815707f, -1.05078878f, -0.58127668f,
        -0.40655590f, -0.24801697f, -0.10196176f, 0.04086834f, 0.18529393f,
        0.33706670f, 0.50439453f, 0.70218800f, 0.96749611f, 1.44163469f,
        1.98681562f, 3.00000000f
    };

    // Coefficients [segment][coefficient]
    constexpr float coeffs[16][5] = {
        { -7.758035540188e-01f, -8.003604294725e-01f, -3.133653731766e-01f, -5.512992228330e-02f, -3.673408105492e-03f },
        { -2.677054230588e-01f, 3.266705662818e-02f, 2.005535457890e-01f, 8.625321433599e-02f, 1.095942021749e-02f },
        { 4.234899225615e-02f, 6.824488781903e-01f, 7.136413833633e-01f, 2.672108268128e-01f, 3.501358268066e-02f },
        { 7.277430655856e-03f, 5.462219563221e-01f, 5.135779552922e-01f, 1.355383829570e-01f, 2.250637012692e-03f },
        { 5.657878872518e-04f, 5.056461609804e-01f, 4.209399498502e-01f, 4.069073561625e-02f, -3.456199376624e-02f },
        { 5.213335351536e-05f, 5.007917807650e-01f, 4.036105593835e-01f, 1.297985787622e-02f, -5.131646128053e-02f },
        { 1.122531011432e-06f, 5.000339516846e-01f, 3.993334587330e-01f, 2.085671479192e-03f, -6.190286744940e-02f },
        { 1.178108444659e-10f, 4.999999859552e-01f, 3.989418993738e-01f, 1.059409872820e-05f, -6.626263767368e-02f },
        { 5.839388675099e-08f, 4.999967720399e-01f, 3.990067141558e-01f, -5.679336721284e-04f, -6.450382460780e-02f },
        { 1.348670659406e-05f, 4.997401354609e-01f, 4.008779487129e-01f, -6.769391480113e-03f, -5.658562656263e-02f },
        { 2.267663245030e-04f, 4.973398929744e-01f, 4.110997327080e-01f, -2.631133430148e-02f, -4.242397173249e-02f },
        { 1.699753277834e-03f, 4.860654596636e-01f, 4.436488788591e-01f, -6.833368463283e-02f, -2.194766886701e-02f },
        { 8.819938521152e-03f, 4.468269437008e-01f, 5.251330007419e-01f, -1.439249141273e-01f, 4.488953970634e-03f },
        { 3.573014832272e-02f, 3.396418584549e-01f, 6.861887974386e-01f, -2.521552538102e-01f, 3.193884545499e-02f },
        { 6.662969902433e-03f, 4.052599452632e-01f, 6.330821155589e-01f, -2.344390277526e-01f, 3.003139687056e-02f },
        { -5.203195447361e-01f, 1.413604140840e+00f, -9.433305411362e-02f, 1.328347038543e-04f, 1.492316615413e-03f },
    };

    // Binary search for segment (log2(16) comparisons)
    int seg = 0;
    int low = 0, high = 15;
    while (low < high) {
        int mid = (low + high + 1) / 2;
        if (x >= breakpoints[mid]) {
            low = mid;
        } else {
            high = mid - 1;
        }
    }
    seg = low;

    // Horner's method evaluation
    float result = coeffs[seg][4];
    result = result * x + coeffs[seg][3];
    result = result * x + coeffs[seg][2];
    result = result * x + coeffs[seg][1];
    result = result * x + coeffs[seg][0];

    return static_cast<std::bfloat16_t>(result);
}

/**
 * @brief DOPRI Deg5 Seg6
 *
 * DOPRI-inspired adaptive piecewise polynomial approximation
 * Degree: 5, Segments: 6
 * Core region: [-3.5, 3.0]
 * Negative tail (x < -3.5): Uses gelu_negative_tail()
 * Positive tail (x >= 3.0): GELU(x) = x
 *
 * Operations: 5 MUL + 5 ADD + log2(6) CMP
 */
std::bfloat16_t gelu_dopri_deg5_seg6(std::bfloat16_t x_bf16) {
    float x = static_cast<float>(x_bf16);

    // Positive saturation
    if (x >= thresholds::POS) {
        return static_cast<std::bfloat16_t>(x);
    }

    // Negative tail: use specialized handler
    if (x < thresholds::TAIL_START) {
        return static_cast<std::bfloat16_t>(gelu_negative_tail(x));
    }

    // Breakpoints for segment lookup
    constexpr float breakpoints[] = {
        -3.50000000f, -2.08209015f, -0.91106857f, 0.19022617f, 0.55653003f,
        1.26642499f, 3.00000000f
    };

    // Coefficients [segment][coefficient]
    constexpr float coeffs[6][6] = {
        { -4.249803634887e-01f, -1.923016736341e-01f, 1.062487633758e-01f, 8.898745868296e-02f, 2.096196566534e-02f, 1.676844090740e-03f },
        { 4.792540746324e-02f, 7.056502021644e-01f, 7.510908607650e-01f, 2.966068886567e-01f, 4.626212844857e-02f, 1.682300787067e-03f },
        { -2.796784596080e-06f, 5.000621742635e-01f, 3.993147199461e-01f, -1.433117145989e-03f, -7.640293904657e-02f, -1.700427550251e-02f },
        { -1.200313752687e-05f, 5.002263210330e-01f, 3.972040008246e-01f, 6.993448449892e-03f, -8.216884130686e-02f, 1.889421275222e-02f },
        { 1.284419941039e-03f, 4.921570018470e-01f, 4.162823600147e-01f, -1.347357932700e-02f, -7.354735125998e-02f, 1.864184046047e-02f },
        { 9.475715572958e-02f, 1.355511158229e-01f, 9.619239139622e-01f, -4.338536099168e-01f, 9.013938827361e-02f, -7.201771989790e-03f },
    };

    // Linear search for segment
    int seg = 0;
    if (x >= breakpoints[1]) seg = 1;
    if (x >= breakpoints[2]) seg = 2;
    if (x >= breakpoints[3]) seg = 3;
    if (x >= breakpoints[4]) seg = 4;
    if (x >= breakpoints[5]) seg = 5;

    // Horner's method evaluation
    float result = coeffs[seg][5];
    result = result * x + coeffs[seg][4];
    result = result * x + coeffs[seg][3];
    result = result * x + coeffs[seg][2];
    result = result * x + coeffs[seg][1];
    result = result * x + coeffs[seg][0];

    return static_cast<std::bfloat16_t>(result);
}

/**
 * @brief DOPRI Deg5 Seg10
 *
 * DOPRI-inspired adaptive piecewise polynomial approximation
 * Degree: 5, Segments: 10
 * Core region: [-3.5, 3.0]
 * Negative tail (x < -3.5): Uses gelu_negative_tail()
 * Positive tail (x >= 3.0): GELU(x) = x
 *
 * Operations: 5 MUL + 5 ADD + log2(10) CMP
 */
std::bfloat16_t gelu_dopri_deg5_seg10(std::bfloat16_t x_bf16) {
    float x = static_cast<float>(x_bf16);

    // Positive saturation
    if (x >= thresholds::POS) {
        return static_cast<std::bfloat16_t>(x);
    }

    // Negative tail: use specialized handler
    if (x < thresholds::TAIL_START) {
        return static_cast<std::bfloat16_t>(gelu_negative_tail(x));
    }

    // Breakpoints for segment lookup
    constexpr float breakpoints[] = {
        -3.50000000f, -2.40914783f, -1.33343878f, -0.48313007f, -0.13455623f,
        0.08407649f, 0.31789859f, 0.58825377f, 0.96896432f, 1.70385783f,
        3.00000000f
    };

    // Coefficients [segment][coefficient]
    constexpr float coeffs[10][6] = {
        { -6.762053224805e-01f, -6.304004024342e-01f, -1.977678191134e-01f, -1.595869383996e-02f, 2.939720081470e-03f, 4.450069714131e-04f },
        { 1.210507795827e-01f, 9.342138612333e-01f, 1.034586965924e+00f, 4.709968266375e-01f, 9.946163549152e-02f, 8.121321453704e-03f },
        { 1.104790458128e-03f, 5.070642192898e-01f, 4.151413218783e-01f, 1.292500863648e-02f, -7.344635885909e-02f, -1.853386506119e-02f },
        { -3.790616588140e-06f, 4.999095306290e-01f, 3.980763821562e-01f, -4.272109458296e-03f, -7.803821124422e-02f, -1.644878915822e-02f },
        { 9.219044546882e-11f, 4.999999705922e-01f, 3.989421007895e-01f, 1.477269150206e-05f, -6.640677161807e-02f, -1.503607218032e-03f },
        { -3.260829173241e-07f, 5.000120324208e-01f, 3.987654232447e-01f, 1.329352990591e-03f, -7.190806676956e-02f, 1.144790379588e-02f },
        { -4.034274442440e-05f, 5.005809064125e-01f, 3.954517576831e-01f, 1.126730131537e-02f, -8.731423410066e-02f, 2.134103184111e-02f },
        { 1.428549283270e-04f, 4.995068983575e-01f, 3.976165465209e-01f, 9.908303357485e-03f, -8.800333097517e-02f, 2.217354422167e-02f },
        { 3.024960086947e-02f, 3.643726686405e-01f, 6.418853032205e-01f, -2.127703343493e-01f, 1.456401130024e-02f, 3.043118499294e-03f },
        { 9.415726928683e-03f, 3.251535213344e-01f, 7.953392451497e-01f, -3.614820415300e-01f, 7.458659426291e-02f, -5.878527601660e-03f },
    };

    // Binary search for segment (log2(10) comparisons)
    int seg = 0;
    int low = 0, high = 9;
    while (low < high) {
        int mid = (low + high + 1) / 2;
        if (x >= breakpoints[mid]) {
            low = mid;
        } else {
            high = mid - 1;
        }
    }
    seg = low;

    // Horner's method evaluation
    float result = coeffs[seg][5];
    result = result * x + coeffs[seg][4];
    result = result * x + coeffs[seg][3];
    result = result * x + coeffs[seg][2];
    result = result * x + coeffs[seg][1];
    result = result * x + coeffs[seg][0];

    return static_cast<std::bfloat16_t>(result);
}

/**
 * @brief DOPRI Deg5 Seg12
 *
 * DOPRI-inspired adaptive piecewise polynomial approximation
 * Degree: 5, Segments: 12
 * Core region: [-3.5, 3.0]
 * Negative tail (x < -3.5): Uses gelu_negative_tail()
 * Positive tail (x >= 3.0): GELU(x) = x
 *
 * Operations: 5 MUL + 5 ADD + log2(12) CMP
 */
std::bfloat16_t gelu_dopri_deg5_seg12(std::bfloat16_t x_bf16) {
    float x = static_cast<float>(x_bf16);

    // Positive saturation
    if (x >= thresholds::POS) {
        return static_cast<std::bfloat16_t>(x);
    }

    // Negative tail: use specialized handler
    if (x < thresholds::TAIL_START) {
        return static_cast<std::bfloat16_t>(gelu_negative_tail(x));
    }

    // Breakpoints for segment lookup
    constexpr float breakpoints[] = {
        -3.50000000f, -2.50334752f, -1.42070349f, -0.68042509f, -0.29568062f,
        -0.12657911f, 0.06491210f, 0.25855679f, 0.47167909f, 0.73252759f,
        1.13794100f, 1.79792897f, 3.00000000f
    };

    // Coefficients [segment][coefficient]
    constexpr float coeffs[12][6] = {
        { -7.439588339145e-01f, -7.439153939712e-01f, -2.735816182660e-01f, -4.119020812402e-02f, -1.244924643727e-03f, 1.683079206406e-04f },
        { 1.287189346961e-01f, 9.548021488106e-01f, 1.056511316199e+00f, 4.825734705145e-01f, 1.024932406541e-01f, 8.436378609832e-03f },
        { 4.976536906289e-03f, 5.276783017753e-01f, 4.583517538572e-01f, 5.751410165770e-02f, -5.078359204439e-02f, -1.399213269818e-02f },
        { -4.914156898843e-05f, 4.993105493717e-01f, 3.949273554408e-01f, -1.250851188232e-02f, -8.875489662166e-02f, -2.199774607183e-02f },
        { -6.063233968472e-07f, 4.999810849950e-01f, 3.987004277610e-01f, -1.624660946613e-03f, -7.255445478961e-02f, -1.199377964527e-02f },
        { -9.171653989569e-11f, 4.999999853991e-01f, 3.989424540294e-01f, 1.102452684866e-05f, -6.649502775675e-02f, -1.837816993257e-03f },
        { -8.846575810223e-08f, 5.000041112960e-01f, 3.988665293062e-01f, 7.103964989975e-04f, -7.008479551662e-02f, 9.372631558043e-03f },
        { -1.420364729474e-05f, 5.002490672795e-01f, 3.971273292839e-01f, 7.060389622940e-03f, -8.206125385729e-02f, 1.873083318079e-02f },
        { -1.155375494284e-04f, 5.013177940671e-01f, 3.925635426931e-01f, 1.692547914766e-02f, -9.285330781774e-02f, 2.350823565875e-02f },
        { 1.979949510230e-03f, 4.887417870846e-01f, 4.227804035242e-01f, -1.942331059862e-02f, -7.095355031636e-02f, 1.821947051232e-02f },
        { 5.403805241320e-02f, 2.781372353402e-01f, 7.662203553765e-01f, -3.018984124151e-01f, 4.633107384290e-02f, -1.461015798080e-03f },
        { -2.776819549147e-02f, 4.036491852133e-01f, 7.295733729252e-01f, -3.341412778645e-01f, 6.894538197153e-02f, -5.416269585882e-03f },
    };

    // Binary search for segment (log2(12) comparisons)
    int seg = 0;
    int low = 0, high = 11;
    while (low < high) {
        int mid = (low + high + 1) / 2;
        if (x >= breakpoints[mid]) {
            low = mid;
        } else {
            high = mid - 1;
        }
    }
    seg = low;

    // Horner's method evaluation
    float result = coeffs[seg][5];
    result = result * x + coeffs[seg][4];
    result = result * x + coeffs[seg][3];
    result = result * x + coeffs[seg][2];
    result = result * x + coeffs[seg][1];
    result = result * x + coeffs[seg][0];

    return static_cast<std::bfloat16_t>(result);
}

/**
 * @brief DOPRI Deg5 Seg16
 *
 * DOPRI-inspired adaptive piecewise polynomial approximation
 * Degree: 5, Segments: 16
 * Core region: [-3.5, 3.0]
 * Negative tail (x < -3.5): Uses gelu_negative_tail()
 * Positive tail (x >= 3.0): GELU(x) = x
 *
 * Operations: 5 MUL + 5 ADD + log2(16) CMP
 */
std::bfloat16_t gelu_dopri_deg5_seg16(std::bfloat16_t x_bf16) {
    float x = static_cast<float>(x_bf16);

    // Positive saturation
    if (x >= thresholds::POS) {
        return static_cast<std::bfloat16_t>(x);
    }

    // Negative tail: use specialized handler
    if (x < thresholds::TAIL_START) {
        return static_cast<std::bfloat16_t>(gelu_negative_tail(x));
    }

    // Breakpoints for segment lookup
    constexpr float breakpoints[] = {
        -3.50000000f, -2.69276242f, -2.01476066f, -1.37297417f, -0.80199375f,
        -0.36714079f, -0.25114990f, -0.10175298f, 0.04084858f, 0.18529770f,
        0.33719275f, 0.50475711f, 0.70341191f, 0.97333533f, 1.45144099f,
        2.05637584f, 3.00000000f
    };

    // Coefficients [segment][coefficient]
    constexpr float coeffs[16][6] = {
        { -8.657540955587e-01f, -9.430506073220e-01f, -4.035053058446e-01f, -8.347336230585e-02f, -8.109182353090e-03f, -2.763923711463e-04f },
        { -8.378769558705e-03f, 6.468457956237e-01f, 7.802882863686e-01f, 3.589107877039e-01f, 7.486109898455e-02f, 5.971081168557e-03f },
        { 1.039245354496e-01f, 8.822860732444e-01f, 9.720364012701e-01f, 4.335782067826e-01f, 8.834402927510e-02f, 6.808659055410e-03f },
        { 7.271152347148e-03f, 5.382067629155e-01f, 4.774143074887e-01f, 7.454067497945e-02f, -4.327955352308e-02f, -1.268631293310e-02f },
        { -9.153290738615e-05f, 4.988844839496e-01f, 3.932371057628e-01f, -1.581750729966e-02f, -9.195279625598e-02f, -2.321884775781e-02f },
        { -6.372709071847e-06f, 4.998723739832e-01f, 3.978765393705e-01f, -4.761496257223e-03f, -7.855198177621e-02f, -1.659822049943e-02f },
        { -2.074543484971e-07f, 4.999921823522e-01f, 3.988219143902e-01f, -9.703204885138e-04f, -7.081951775310e-02f, -1.018088778529e-02f },
        { -3.587020068817e-11f, 4.999999981951e-01f, 3.989424291924e-01f, 3.624696779365e-06f, -6.655268663565e-02f, -1.817489879718e-03f },
        { -9.642646018957e-09f, 5.000006661012e-01f, 3.989242455822e-01f, 2.458986644839e-04f, -6.828173192333e-02f, 6.659872035192e-03f },
        { -2.316043532723e-06f, 5.000561086276e-01f, 3.983793160641e-01f, 2.999835079406e-03f, -7.547576313816e-02f, 1.445668881351e-02f },
        { -3.121397316765e-05f, 5.004676182568e-01f, 3.960089297752e-01f, 9.909608008147e-03f, -8.567472018299e-02f, 2.055590625855e-02f },
        { -1.206675298280e-04f, 5.013593960481e-01f, 3.924293716479e-01f, 1.714057865546e-02f, -9.302471913933e-02f, 2.356255260711e-02f },
        { 5.684656303086e-04f, 4.968908345075e-01f, 4.040236124612e-01f, 2.092756114866e-03f, -8.325478028490e-02f, 2.102387381496e-02f },
        { 1.723361918009e-02f, 4.181143277958e-01f, 5.536868903202e-01f, -1.408484410814e-01f, -1.458053246429e-02f, 7.738844736561e-03f },
        { 1.172491802306e-01f, 7.875905883677e-02f, 1.017440069653e+00f, -4.599514897686e-01f, 9.597880142999e-02f, -7.689899662970e-03f },
        { -1.630416947367e-01f, 6.776085369969e-01f, 5.087618385451e-01f, -2.455983522476e-01f, 5.128026156480e-02f, -4.013318796278e-03f },
    };

    // Binary search for segment (log2(16) comparisons)
    int seg = 0;
    int low = 0, high = 15;
    while (low < high) {
        int mid = (low + high + 1) / 2;
        if (x >= breakpoints[mid]) {
            low = mid;
        } else {
            high = mid - 1;
        }
    }
    seg = low;

    // Horner's method evaluation
    float result = coeffs[seg][5];
    result = result * x + coeffs[seg][4];
    result = result * x + coeffs[seg][3];
    result = result * x + coeffs[seg][2];
    result = result * x + coeffs[seg][1];
    result = result * x + coeffs[seg][0];

    return static_cast<std::bfloat16_t>(result);
}
